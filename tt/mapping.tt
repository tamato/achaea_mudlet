#nop Create map as we get it.

#read shopRoomNumbers.tt;

#var mapping[callbacks] {};
#var mapping[paused] 0;

#alias {mapping} {
   print Mapping Commands;
   info * mgo;
   info   - mapping go to, pass in room num;
   info * mgostart;
   info   - go to the start room;
   info * mexplore;
   info * mstop;
   info ;
}

#alias {mapping.onConnected}
{
   #map create;
   #map flag static;
   #map flag unicode;
   #map flag nofollow;
   #map read world.map;

   #nop seems to be either to use draw or vtmpa/split/offset;
   #draw boxed map 1 1 $uimap[height] $uimap[width];
}

#nop Map Go To, room num
#alias {mwalk} {
   #var mapping[dst] %1;
   #map find {%1};
}

#alias {mrun} {
   #var mapping[dst] %1;
   #map find {%1};
   #path run {0.7};
}

#alias {mgostart} {
   mrun {$mapping[startRoom]};
}

#alias {mstop} {
   #list mapping[yetToVisit] clear;
   #class pathing clear;
   #path destroy;
}

#alias {mapping.prepExplore} {
   #map get {roomvnum} {mapping[startRoom]};
   #list mapping[yetToVisit] clear;

   #nop List contains distance to each room;
   #map list {roomid}{@getAreaId{}} {variable}{rooms};
   #foreach *rooms[] roomid {
      #list mapping[yetToVisit] ins -1 $roomid;
   };

   #nop don't bother with the room we are starting in.;
   #list mapping[yetToVisit] find $mapping[startRoom] idx; 
   #if {$idx != 0} {
      #list mapping[yetToVisit] delete $idx;
   };

   #unvar rooms;
   #unvar roomid;
}

#alias {mexplore} {
   #class pathing load;
   #var mapping[paused] 0;

   mapping.prepExplore;
   #var mapping[callbacks][explore] {mapping.step};

   #nop We got the list of rooms to tarverse, now lets go.;
   mapping.nextdest;

   #path walk;
}

#alias {mapping.step} {
   #show it is delayed;
   #delay {0.7} {
      #path save forward stupid;
      #var stupid;
      #path walk;
   };
}

#alias {mapping.nextdest} {
   #if {&mapping[yetToVisit][] > 0} {
      #local dst $mapping[yetToVisit][+1];
      #list mapping[yetToVisit] delete +1;

      #nop onRoomInfo will be called and will call into mapping.step;
      mwalk $dst;
   };
}

#EVENT {END OF PATH} {
   #unvar $mapping[callbacks][explore];
   #path destroy;
   #if {$mapping[paused] == 1} {#return};

   print Walked, Reached destination;

   #nop Clean up;
   #if {&mapping[yetToVisit][] == 0} {
      print Finished AutoExplore;

      #class pathing clear;
      #unvar $mapping[dst];
   };

   #nop if we are not done, head to the next room;
   print Going to next dest;
   mapping.nextdest;
}

#EVENT {END OF RUN} {
   #if {$mapping[paused] == 1} {#return};

   print Run, Reached destination;

   #nop Clean up;
   #if {&mapping[yetToVisit][] == 0} {
      print Finished AutoExplore;

      #class pathing clear;
      #unvar $mapping[callbacks][explore];
      #unvar $mapping[dst];
   };

   #nop #foreach $mapping[callbacks][] cb {
      #nop #if {"$cb" != ""}{$cb};
   #nop };
}

#alias {mapping.onRoomInfo}
{
   #if {&{gmcp[room][info][num]} === 0}{#return};

   #map goto {$gmcp[room][info][num]};

   #draw boxed map 1 1 $uimap[height] $uimap[width];

   #math width {$uimap[width] - 4};

   #nop Put the area name at the top of the map;
   #format {prompt} {%.${width}s} {<038>$gmcp[room][info][area]};
   #line ignore #showme {$prompt} {1} {3};

   #nop Put the room name at the bottom of the map;
   #format {prompt} {%.${width}s} {<038>$gmcp[room][info][name]};
   #line ignore #showme {$prompt} {$uimap[height]} {3};

   #nop Display the exits;
   #variable {exits} {};
   #foreach {n;e;s;w;u;d;in;out;nw;ne;se;sw} {exit}
   {
       #if {&{gmcp[room][info][exits][$exit]} === 0} { #continue };
       #variable {exits} {$exits<128>$exit<270>,};
   };

   #screen clear square {$uimap[height]+1} 1 {$uimap[height]+1} {$uimap[width]-1};
   #format {prompt} {%u} {$exits<099>};
   #line ignore #showme {$prompt} {$uimap[height]+1} {2};
   #unvar exits;

   #nop Find the current room and remove it from the rooms to go to.;
   #if {&mapping[yetToVisit][] > 0} {

      #list mapping[yetToVisit] find {$gmcp[room][info][num]} idx; 

      #nop Carefull, we may hit the same room many times;
      #if {$idx != 0} {
         #show Deleted $idx, $mapping[yetToVisit][$idx];
         #list mapping[yetToVisit] delete $idx;
      };

      print Running mapping callbacks;
      #foreach $mapping[callbacks][] cb {
         #if {"$cb" != ""}{$cb};
      };
   };

   #nop Watch for differences in room names to update the crowd map.;
   #nop #map get roomname rname;
   #nop #local gmcpName $gmcp[room][info][name];
   #nop #if {"^$gmcpName" != "^$rname$"} { print Room names differ! $gmcpName and $rname; };
}

#func {getAreaId} {
   #map get {roomid} areaid;
   #return $areaid;
}

#class pathing kill;
#class pathing open;

#action {^There is no exit in that direction.$} {
   #var mapping[paused] 1;
   #list mapping[yetToVisit] clear;
   print No Path;
   #path destroy;
}

#action {^Now now, don't be so hasty!$} {
   #var mapping[paused] 1;
   print Stopped Path;

   #delay {1} {
      #var mapping[paused] 0;
      #nop mapping.step;
   };
}

#class pathing close;
#delay 5 {#class pathing save};
#delay 7 {#class pathing clear};

#alias {directory} 
{
   #send {directory %1};
   #class roomnums load;

   #var eventCallbacks[prompt][directory] {
      #class roomnums clear; 
      #unvar eventCallbacks[prompt][directory];
   };
}

#class roomnums kill;
#class roomnums open;

#action {^%dgp %* {[A-Z]%*}%*$} {
   #var shopnum { ??? };
   #loop 1 {&shops[49][]} idx {
      #if {{^%3%4$} == {^*shops[49][+$idx]$}} {
         #var shopnum $shops[49][+$idx];

         #line oneshot #sub {%*} {%%1:<269>$shopnum<099>};
         #break;
      };
   };
   #unvar idx;
}

#class roomnums close;
#class roomnums save;

